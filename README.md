# TCP-IP

1. 개요

 이 프로그램은 리눅스의 Epoll을 이용한 다중접속 채팅 프로그램임.

2. 목적

 1:1 프로그램의 한계인 메세지를 전송시 다음 메세지를 기다리는 상태를 극복함과 동시에 많은 클라이언트들이 접속하여 메세지를 주고 받기 위함.
 
 차후 Texas holedem의 프로그램과 연계하여 다중 클라이언트 포커게임을 만들기 위함.

3. 개발 및 실행환경

 Linux ubuntu 16.04 LTS
 
 Vim

4. 실행방법

 가) 터미널을 열고 소스파일이 있는 디렉토리로 이동한다.
 
 나) 이 후 터미널에서 g++ -o client epoll_client.cpp -lpthread 를 입력하고. client 파일이 생성 되었는지 확인한다.(클라이언트만 스레드 2개 만듬)
 
 다) 이 후 터미널에서 g++ -o server epoll_server.cpp 를 입력하고. server 파일이 생성 되었는지 확인한다.
    주의: g++로 컴파일이 안될 시에 g++을 설치할 것.우분투는 기본적으로 g++이 설치되어 있지 않음
 
 라) 터미널로 ./server 를 입력.
 
 마) 또다른 터미널을 열고 컴파일이 된 디렉토리로 이동을 한뒤 ./client 127.0.0.1 3600 을 실행.
 

5. 제한사항

 가) 접속을 끊으면 epollfd에 삭제되는 코드를 제대로 구현안함.
 
 나) Signal 예외처리 안해서 server를 강제종료하면 kill을 해줘야함 (ps명령어 치고 PID(Process ID)보고 Kill -9 PID)

6. 상세설명

 설명하기 앞서 이 프로그램은 banu.com 사이트의 epoll 예제를 참고하여 만든 것이다.
 
 이 프로그램은 동기/비봉쇄 모델을 가지는 Epoll을 사용하였고, select함수의 비효율성을 극복하는 장점을 가지고 있다.
 
 Epoll은 FreeBSD의 kqueue(Mac OS),Window의 IOCP(Window)와 똑같은 함수이다.
 
 먼저 풀(epoll_create1)을 만들고 listen 대기열로 들어왔다는 정보를 먼저 풀(epollfd)에 추가(epoll_ctl)를 한다.
 
 epoll_wait로 무한대기 상태에서 클라이언트 이벤트가 발생하면 루프문을 통해 풀로 들어온 정보를 체크하면서 새로 접속한 클라이언트에 대해서는 풀 추가.

 (EPOLL_CTL_ADD)를 하고 기존 클라이언트의 정보가 바뀐 것을 확인 했을때는, read를 통해 성공시 메세지를 읽는다.
 
 그것을 다시 epollfd에 있는 접속 된 클라이언트들에 다시 write해서 보낸다.
 
 여기서 banu.com 소스부분과 다른 점은 클라이언트가 접속 시에 이름을 묻고 다시 그 정보를 받아와서 epoll_ctl을 통해 수정을 한다는 점.
 
7. 문제점

 가) 클라이언트 부분의 경우 메세지 작성 도중 다른 클라이언트의 메세지를 받을때 쓰던 메세지가 지워져서 다시 작성해야함.
 
 나) 주석이 허접함(영어랑 한글이랑 같이 넣음 이해 안될 것 같은 부분은 한글로 설명)
 
 다) 코드가 더러움.
